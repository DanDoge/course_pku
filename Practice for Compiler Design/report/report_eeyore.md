### EEyore2Tigger

这一部分的报告包括Eeyore到Tigger的程序的功能，拓展。

这一部分的代码能够将单个符合Eeyore的BNF文法的程序转换成符合Tigger文法的程序。除了下面列出来的功能，其他的数据结构和实现方法和翻译Minic类似。

#### 数据结构

类似minic部分的实现，将节点分为定义变量、定义函数和表达式。
- 表达式节点继续分类为双目表达式、单目表达式等
- 辅助翻译表达式节点，将运算符也进一步分类，和op_table中的运算符字符串一一对应

节点内部的数据结构包括
- 子节点指针
- 下一条语句/节点的指针
- 母节点 e.g. 当前节点从属的函数节点
- 前一条语句，数据流分析用
- 节点/表达式/运算符类型
- 节点名 e.g. 函数/变量/标签名
- 数组大小/常数值/栈大小
- use/define/live数组，活性分析用
- 变量表: 函数节点用
	- 变量表内部的数据结构包括: 变量名，栈中位置，是否是全局节点，参数，所属寄存器，是否在寄存器中

在课程要求之外，我实现了以下的功能
- 简单优化：常量表达式消除
- 线性扫描寄存器分配算法

#### 常量表达式消除

在翻译双目运算符时，如果每一个运算数都是数字，可以翻译过程中直接计算出来，具体实现参考下面的例子

```c++
int get_result(int a, int b, Op_Type op){
    int res = 0;
    switch(op){
        case OP_EQ:{
            res = a == b;
            break;
        }
        // more cases
    }
    return res;
}
```

#### 线性寄存器分配

我将每一个语句看作一个基本块，记录每一条语句上活跃的变量
- 预处理
	- 在parse代码时将各个语句按出现先后顺序组织起来，
    - 构建数据流：主要是扫描if和goto语句，找到对应的下一/二条语句；其他语句的下一条语句默认是下一行语句
    - 活性分析：记录每一条语句的use和define
        - 对数组的每一次访问都看作使用整个数组
        - 按照之前构造的数据流倒序分析活性，以函数为单位，扫描所有语句迭代直到收敛
- 分配寄存器：每一个变量对应一个寄存器
    - 从前向后扫描每一条语句，如果有变量没有分配寄存器，分配一个空缺的寄存器，没有空缺的，踢掉最后活跃时间最晚的一个变量，释放它占据的寄存器
    - 变量使用 **不** 按照RISC规范，所有寄存器都看作caller saved，调用函数时保存活跃的变量，返回后写回寄存器
