# 作业

计时程序

作业要写出带宽大小, 凝聚访问

可以先用memcpy做一下, 比较一下

# 内存层级

共享存储器可以用索引访问

```c
__shared__ int a[16] //在共享存储器里面, 一个block的线程都看得见

int a[16] //在寄存器里面, 别人看不见

a[(int )x] //寄存器不能动态索引, 共享存储器可以
a[7] //寄存器可以这样访问
```

但是寄存器访问比共享存储器快2-4倍, 最好只用它做通讯

共享存储器分路, 如果都想访问同一路, 就要排队

64并行就很快, 正好是两个worp, 但是要是有一个变元在shared mem里面, 就只能到60%

##### 下面很重要

一些晶体管计算, 一些存储

没有存储的话, 做矩阵乘法就很吃力, 需要大量访存$$O(n^{3})$$, 可以全读到芯片里面shared mem, 这样访存只有$$O(n^{2})$$

KNL: 底层DDR-4 100+G/s, 芯片上堆叠的存储器, 400+G/s

GPU上面量就比较小, 需要充分利用, 如何做到? 分块, 控制粒度, 充分利用共享存储器

计算太快, 访存太慢, 如果都需要访存的话, 需要等很久

$$\sum_{i} x[i] \times 2$$, 每一次运算只有0.23个字节传进来, 但是计算一次需要2字节的数据(乘加算两个运算) ==> 计算比

访存要重复利用, 4 / 0.23, 需要18次重复利用

优化? 分块, 数据放到shared mem里面, 或者分块放到片上

在A里面取一行, B里面取一列, 读入data = 4(n + m)byte, 计算进行2mn flops(乘加算作两次), comp / data = $$\frac{1}{2(\frac{1}{m} + \frac{1}{n})}$$, 之前的 comp / data = 1 / 4, 比值达到$$\frac{2}{\frac{1}{m} + \frac{1}{n}}$$

利用分块, 有暂存机制, 可以减少重复访问的次数, 比方说取 m = 64, n = 16, 达到26次重用

重用越多越好? 计算密度成为瓶颈了, 调参

**cuda.ppt p7**

计算$$C = C + \alpha A + \beta B$$

一个block64个线程, 每一个线程进行16个元素计算, 粒度

读一行是凝聚的, 但是读一列是跳着的, 不好, 一次读多行

把B的一块放到shared里面, 每一次读四行(Idb是一行的宽度), 这样多个线程就是凝聚访问

线程太多的话寄存器就少了

```c
#pragma unroll //循环展开, 循环变量编译时可知, 很快, 还要把数据相关拉开
```

为什么要同步? 读数据读到共享存储器里面, 进来的数据可能是别人用的, block内线程同步, 第二个同步保证转回来的时候不会产生坏数据

16 * 17? 错开一位, 减少bank conflict
