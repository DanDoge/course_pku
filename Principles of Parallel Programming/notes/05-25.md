
```text
W(var) value
R(var) value // 这一次读出value, 下一次不一定

x = x + 1 ==> P1: R(x) 0, W(x) 1
```

严格一致性: 任何读操作都读到最近一次写的结果, 依赖于全局时钟(物理时钟)

如果读写不是原子操作的话, 可能出现

```text
W(x) 1
--------------------
       R(x) 0 R(x) 1
```

如果放一个互斥锁, 那就能严格一致了

顺序一致性: 任何一次并发 **执行** 顺序结果都一直, 好像操作按照顺序进行, 可以构造一个全序

```text
W(x) 1
R(x) 1 R(x) 2
R(x) 1 R(x) 2
W(x) 2
```
就是有序的, 可以认为如下执行

```text
W(x) 1
        R(x) 1          R(x) 2
        R(x) 1          R(x) 2
                W(x) 2
```

但是下面的就不行

```text
W(x) 1
R(x) 1 R(x) 2
R(x) 2 R(x) 1
W(x) 2
```

顺序一致性应用: dijkstra, 反复运行, 反复更新且其他线程见过我终止的状态, 进入终止准备状态

弱一致性: 对同步变量的访问时顺序一致的, 之前的所有写操作完成之后才能读同步变量, 之前的所有读操作完成之后才能写同步变量

```text
W(x) 1 W(x) 2
R(x) 0 R(x) 2 s R(x) 2
R(x) 1 s R(x) 2
```

s是同步指令, 同步指令之后, 读到的值就是准的, 写的操作没有义务广播出去, 没有同步指令, 最新的修改可能看不到, 读操作之前同步一下就好了, on demand

因果关系, 看信号量就好了, 假如有因果关系, 看到的顺序就一致, 如果没有因果关系, 看到的顺序随便了, 只是一个偏序

满足顺序一致一定因果一致

强一致性 > 顺序一致性 > 因果一致性
