# 作业

矩阵转置, 自己写

sigmod

# 这节课

线程多? 不一定好

cuda: C语言不必关心cache

线程私有寄存器,

local memory, 编译时的一个概念, 物理上不存在

constant: 运行的时候不会变化, 但是每次运行开始前会变化

text memory: 二位cache, 一个点周围的点被读进来

GPU没有大的cache? 大量访存, 不同线程的数据共享很少

fma: cpu上, a*b + c 和 a*b的时间是一样的

芯片访存的延迟, dram里面也有一个小cache, 访存多就排队

warp: 32个线程, 所有GPU都是一样的

凝聚访问? 访问的内存是对齐的

```c
if(x < 0){
    bar();
}else{
    foo();
}
```

如何执行? 两条指令所有线程都执行, 流水线是相同的, 只是有的人空转

错位访问内存就不凝聚, 访存会变成两条访问

x86精度会高点
